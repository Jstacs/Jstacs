\documentclass[a4paper]{report}
\pagestyle{plain}

\usepackage{listings}
\lstset{language=Java,basicstyle=\small\ttfamily}
\usepackage{fp}

\input{defs}
\hypersetup{
	pdfauthor = {Jan Grau and Jens Keilwagen}, pdftitle = Jstacs Cookbook
}

\newcounter{off}
\setcounter{off}{1}
\newcounter{first}
\setcounter{first}{1}
\newcounter{last}
\setcounter{last}{1}

\newcommand{\codefile}{../codeExamples/NewCodeExampleTest.java}
\newcommand{\code}[1]{%
\setcounter{first}{\value{off}}%
\setcounter{last}{\value{off}}%
\addtocounter{last}{#1}%
\lstinputlisting[firstline=\arabic{off},lastline=\arabic{last},tabsize=1,breaklines=true]{\codefile}}

\begin{document}


\section{Preface}

Teile vom Jstacs-Paper?

\section{Starter: Data handling}

In Jstacs, data is organized at three levels:
\begin{itemize}
  \item \Alphabet s for defining single symbols, and \AlphabetContainer s for defining aggregate alphabets,
  \item \Sequence s for defining sequences of symbols over a given alphabet,
  \item \DataSet s for defining sets of sequences.
\end{itemize}
Sequences are implemented as an array of numerical values. In case of discrete sequences over some symbolic alphabet,
the symbols are mapped to contiguous discrete values starting at $0$, which can be mapped back to the original symbols
using the alphabet. This mapping is also used for the \lstinline{toString()} method, e.g., for printing a sequence. The actual 
data type, i.e. byte, short, or integer, used to represented the symbols is chosen internally depending on the size of 
the alphabet. \Alphabet s, \Sequence s, and \DataSet s are immutable for reasons of security and data consistency. That means, an instance of those
classes cannot be modified once it has been created.

\subsection{Alphabets}

Since Jstacs is tailoured at sequence analysis in bioinformatics, the most prominent alphabet is the \DNAAlphabet, which is a singleton instance that can be accessed by:
\addtocounter{off}{120}
\code{0}
For general discrete alphabets, i.e., any kind of categorical data, you can use a \DiscreteAlphabet. Such an alphabet can be constructed in case-sensitive and insensitive variants (first argument) using a list of symbols.
In this example, we create a case-sensitive alphabet with symbols "W", "S", "w", and "x":
\addtocounter{off}{3}
\code{0}
If you rather want to define an alphabet over contiguous discrete numerical values, you can do so by calling a constructor that takes
the maximum and minimum value of the desired range, and defines the alphabet as all integer values between minimum and
maximum (inclusive). For example, to create a discrete alphabet over the values from $3$ to $10$, you can call
\addtocounter{off}{3}
\code{0}
Continuous alphabets are defined over all reals (minus infinity to infinity) by default (see first line in the following example).
However, if you want to define the continuous alphabet over a specific interval, you can specify the maximum and the minimum value of that interval. In the example, we define a continuous alphabet spanning all reals between $0$ and $100$:
\addtocounter{off}{3}
\code{1}

For the DNA alphabet, each symbols has a complementary counterpart. Since in some cases, a similar complementarity
can also be defined for symbols other than DNA-nucleotides (e.g., for RNA sequences containing U instead of T), Jstacs
allows to define generic complementable alphabets. These allow for example the generation of reverse complementary sequences
out of an existing sequence. Here, we define a binary alphabet of symbols ``A'' and ``B'', where ``A'' is the complement of ``B'' and vice versa.
\addtocounter{off}{4}
\code{0}
The first parameter again defines if this alphabet is case-insensitive (which is the case), the second parameter defines the symbols of the alphabet, and the third parameter specifies the index of the complementary symbol. For instance, the symbol at position $1$ (``B'') is set as the complement of the symbol at position 0 (``A'') by setting the $0$-th value of the integer array to $1$.

After the definition of single alphabets, we switch to the creation of aggregate alphabets. Almost everywhere in Jstacs, we use aggregate alphabets
to maintain generalizability. Since the aggregate alphabet containing only a \DNAAlphabet~is always the same, a singleton for such an \AlphabetContainer~is pre-defined:
\addtocounter{off}{3}
\code{0}
We can explicitly define an \AlphabetContainer~using a simple continuous alphabet by calling:
\addtocounter{off}{3}
\code{0}

Aggregate alphabets become interesting if we need different symbols at different positions of a sequence, or even a mixture of discrete and continuous values.
For example, we might want to represent sequences that consist of a DNA-nucleotide at the first position, some other discrete symbol at the second position, and  a real number stemming from some measurement at the third position. Using the \DNAAlphabet, the discrete \Alphabet, and the continuous \Alphabet~defined
above, we can define such an aggregate alphabet by calling
\addtocounter{off}{3}
\code{0}
To save memory, we can also re-use the same alphabet at different position of the aggregate alphabet. If we want to use a \DNAAlphabet~at positions $0$, $1$, and $3$, and a continuous alphabet at positions $2$, $4$, and $5$, we can use a constructor that takes the alphabets as the first argument and the assignment to the positions as the second argument:
\addtocounter{off}{3}
\code{0}
The alphabets are assigned to specific positions by their index in the array of the first argument.

\subsection{Sequences}

Single sequences can be created from an \AlphabetContainer~and a string. However, in most cases, we load the data from some file, which will be explained
in the next sub-section.
For creating a DNA sequence, we use a \DNAAlphabet~like the one defined above and a string over the DNA alphabet:
\addtocounter{off}{3}
\code{0}
In a similar manner, we define a continuous sequence. In this case, a single value is represented by more than one letter in the string. Hence, 
we need to define a delimiter between the values as a third argument, which is a space in the example.
\addtocounter{off}{3}
\code{0}
We can also create sequences over the mixed alphabet defined above. In the example, the single values are delimited by a ``;''.
\addtocounter{off}{3}
\code{0}
For very large amounts of data or very long sequences, even the representation of symbols by byte values can be too memory-consuming. Hence, 
Jstacs also offers a representation of DNA sequences in a sparse encoding as bits of long values. You can create such a \SparseSequence~from a \DNAAlphabet~
and a string:
\addtocounter{off}{3}
\code{0}
However, the reduced memory footprint comes at the expense of a slightly increased runtime for accessing symbols of a \SparseSequence. Hence, it is not the default representation in Jstacs.

After we learned how to create sequences, we now want to work with them. First of all, you can obtain the length of a sequence
from its \lstinline+getLength()+ method:
\addtocounter{off}{3}
\code{0}
Since on the abstract level of \Sequence~we do not distinguish between discrete and continuous sequences (and we also may have mixed sequences), there are
two alternative methods to obtain one element of a sequence regardless of its content. With the first method, we can obtain the discrete value at a certain position (2 in the example):
\addtocounter{off}{3}
\code{0}
If the \Sequence~contains a continuous value at this position, it is discretized by default by returning the distance to the minimum value of the continuous alphabet
at this position casted to an integer. If the \Sequence~contains a discrete value, that value is just returned in the encoding according to the \AlphabetContainer.
In a similar manner, we can obtain the continuous value at a position (5 in the example)
\addtocounter{off}{1}
\code{0}
where discrete values are just casted to \lstinline+double+s.

We can obtain a sub-sequence of a \Sequence~using the method \lstinline+getSubSequence(int,int)+, where the first parameter is the start position within the sequence, counting from $0$, and the second
parameter is the length of the extracted sub-sequence. So the following line of code would extract a sub-sequence of length $3$ starting at position $2$ of the original sequence or, stated differently,
we skip the first two elements, extract the following three elements, and again skip everything after position $4$.
\addtocounter{off}{3}
\code{0}
Since \Sequence s in Jstacs are immutable, this method returns a new instance of \Sequence, which is assigned to a variable \lstinline+contSub+ in the example. Hence, in cases where you need
the same sub-sequences frequently in your code, for example in a ZOOPS-model or other models using sliding windows on a \Sequence, we recommend to precompute these sub-sequences and store them in some auxiliary data structure in order to invest runtime in computations rather than garbage collection. Internally, sub-sequences only hold a reference on the original sequences and the start position and length within that sequence to keep the memory overhead of sub-sequences at a low level.

For \Sequence s defined over a \ComplementableDiscreteAlphabet~like the \DNAAlphabet, we can also obtain the (reverse) complement of a sequence. For example, to create
the reverse complementary sequence of a complete sequence, we call
\addtocounter{off}{3}
\code{0}
For the complement of a sub-sequence of length $6$ starting at position $3$ of the original sequence, we use
\addtocounter{off}{3}
\code{0}

For some analyses, for instance permutation tests or for estimating false-positive rates of predictions, it is useful to create permuted variants of an original sequence.
To this end, Jstacs provides a class \PermutedSequence~that creates a randomly permuted variant using the constructor
\addtocounter{off}{3}
\code{0}
or a user-defined permutation by an alternative constructor. In the randomized variant, the positions of the original sequence are permuted independently of each other, which means that higher order properties of the sequence like di-nucleotide content are not preserved. If you want to create sequences with similar higher-order properties, have a look at the \lstinline+emitSample()+ method of \HomogeneousModel.

Often, we want to add additional annotations to a sequence, for instance the occurrences of some binding motif, start and end positions of introns, or just the species a sequence is stemming from. To this end, Jstacs provides a number of \SequenceAnnotation s that can be added to a \Sequence~(or read from a FastA-file as we will see later).
For instance, we can add the annotation for binding site of a motif called ``new motif'' of length $5$ starting at position $3$ of the forward strand of sequence \lstinline+dnaSeq+ using the \lstinline+annotate+ method of that sequence:
\addtocounter{off}{3}
\code{0}
Again, this method creates a new \Sequence~object due to \Sequence s being immutable.
After we added several \SequenceAnnotation s to a \Sequence, we can obtain all those annotations by calling
\addtocounter{off}{3}
\code{0}
For retrieving annotations of a specific type, we can use the method \lstinline+getSequenceAnnotationByType+
\addtocounter{off}{3}
\code{0}
to, for instance, obtain the first (index $0$) annotation of type ``Motif''.

\subsection{DataSets}
In most cases, we want to load \Sequence s from some FastA or plain text file instead of creating \Sequence s manually from strings. In Jstacs, collections of \Sequence s are represented by
\DataSet s. The class \DataSet~(and \DNADataSet) provide constructors that work on a file or the path to a file, and parse the contents of the file to a \DataSet, i.e. a collection of \Sequence s.

The most simple case is to create a \DNADataSet~from a FastA file. To do so, we call the constructor of \DNADataSet with the (absolute or relative) path to the FastA file:
\addtocounter{off}{3}
\code{0}
For other file formats and types of \Sequence s, \DataSet~provides another constructor that works on the \AlphabetContainer for the data in the file, a \StringExtractor~that handles the extraction of
the strings representing single sequences and skipping comment lines, and a delimiter between the elements of a sequence. Hence, the \StringExtractor, a \SparseStringExtractor~in the example, requires the specification of the path to the file and the symbol that indicates comment line. For example, if we want to create a sample of continuous sequences stored in a tab-separated plain text file ``myfile.tab'', we use the \AlphabetContainer~with a continuous \Alphabet~from above, a \StringExtractor~with a hash as the comment symbol, and a tab as the delimiter:
\addtocounter{off}{3}
\code{0}
The \SparseStringExtractor~is tailoured to files containing many sequences, and reads the file line by line, where each line is converted to a \Sequence~and discarded before the next line is parsed.

Since \SparseSequence s are not one of the default representations of sequence in Jstacs (see above), these are not created by the constructors of \DataSet~or \DNADataSet. However, the class \SparseSequence~provides a method \lstinline+getSample+ that takes the same arguments as the constructor of \DataSet, for example
\addtocounter{off}{3}
\code{0}
for reading DNA sequences from a FastA file, and returns a \DataSet~containing \SparseSequence s.

After we successfully created a \DataSet, we want to access and use the \Sequence s within this \DataSet. We retrieve a \Sequence~of a \DataSet~using the method \lstinline+getElementAt(int)+. For instance,
we get the fifth \Sequence~of \lstinline+dnaSample+ by calling
\addtocounter{off}{3}
\code{0}
We can also request the number of \Sequence s in a \DataSet~by the method \lstinline+getNumberOfElements()+ and use this information, for instance, to
iterate over all \Sequence s. In the example, we just print the retrieved \Sequence s to standard out
\addtocounter{off}{2}
\code{2}
where the \Sequence s are printed in their original alphabet since their \lstinline+toString()+ method is overridden accordingly.

As an alternative to the iteration by explicit calls to these methods, \DataSet~also implements the \lstinline+Iterable+ interface, which facilitates the Java variant
of foreach-loops as in the following example:
\addtocounter{off}{5}
\code{2}
Here, we just print the length of each \Sequence~in \lstinline+contSample+ to standard out.

We can also apply some of the sequence-level operations to all \Sequence s of a \DataSet, and obtain a new \DataSet~containing the modified sequences. For example, we get a \DataSet~containing 
the sub-sequences of length $10$ starting at position $3$ of each sequence by calling
\addtocounter{off}{5}
\code{0}
a \DataSet~of all suffixes starting at position $7$ from
\addtocounter{off}{3}
\code{0}
or a \DataSet~containing all reverse complementary \Sequence s using
\addtocounter{off}{3}
\code{0}

For cross-validation experiments, hold-out samplings, or similar procedures, it is useful to partition a sample randomly. \DataSet s in Jstacs support two types of partitionings.
The first is to partition a \DataSet~into $k$ equally sized parts. What is ``equally sized'' can either be determined by the number of sequences or by the number of symbols of all sequences in a sample. Both measures are supported by Jstacs. 

The second partitioning method creates partitions of a user-defined fraction of the original sample. For example, we partition the \DataSet~\lstinline+dnaSample+ into five equally sized parts according to the number of sequences in that \DataSet~by calling
\addtocounter{off}{3}
\code{0}
and we partition the same sample into parts containing $10$, $20$, and $70$ percent of the symbols of the original \DataSet by calling
\addtocounter{off}{1}
\code{0}
In both cases, the \Sequence s in the \DataSet~are partitioned as atomic elements. That means, a \Sequence~is not cut into several parts to obtain exactly equally sized parts, but the size of a part may slightly (depending on the number of sequences and lengths of those sequences) differ from the specified percentages.

To create a new \DataSet~that contains all sub-sequences of a user-defined length of the original \Sequence s, we can use another constructor of \DataSet. The sub-sequences are extracted in the same manner as we would do by shifting a sliding window over each sequence, extracting the sub-sequence under this window, and build a new \DataSet~of the extracted sub-sequences.
For instance, we obtain a \DataSet~with all sub-sequences of length $8$ using
\addtocounter{off}{3}
\code{0}

In the previous sub-section, we learned how to add \SequenceAnnotation s to a \Sequence. Often, we want to use the annotation that is already present in an input file, for example
the comment line of a FastA file. We can do so by specifying a \SequenceAnnotationParser~in the constructor of the \DataSet. The simplest type of \SequenceAnnotationParser~ is the \SimpleSequenceAnnotationParser, which just extracts the complete comment line preceding a sequence.
\addtocounter{off}{3}
\code{0}
Although the specification of the parser is quite simple, the extraction of the comment line as a string is a bit lengthy. We first obtain the \Sequence~from the \DataSet, get the annotation of that sequence, obtain the first comment, called ``result'' in the hierarchy of Jstacs (you see in section~\ref{sec:xmlparres}, why), and convert the corresponding result object to a string.
\addtocounter{off}{3}
\code{0}

If your comment line is defined in a ``key-value'' format with some generic delimiter between entries, you can Jstacs let parse the entries to distinct annotations. For instance, if the comment line has some format \lstinline+key1=value1; key2=value2;...+, we can parse that comment line using the \SplitSequenceAnnotationParser. This parser only requires the specification of the delimiter between key and value (``=`` in the example) and the delimiter between different entries (``;'' in the example). Like before, we instantiate a \SplitSequenceAnnotationParser~as the last argument of the \DNADataSet~constructor:
\addtocounter{off}{3}
\code{0}
We can now access all parsed annotations by the \lstinline+getAnnotation()+ method
\addtocounter{off}{3}
\code{0}
or, for instance, the \lstinline+getSequenceAnnotationByType+ introduced in the previous section, where the type corresponds to the key in the comment line, and the identifier of the retrieved \SequenceAnnotation~is identical to the value for that key in the comment line.

Jstacs only supports FastA and plain text files directly. However, you can access other formats or even data bases like Genbank using an adaptor to BioJava.

For example, we can use BioJava to load two sequences from Genbank.
\addtocounter{off}{3}
\code{6}
As a result, we obtain a \lstinline+RichSequenceIterator+, which implements the \lstinline+SequenceIterator+ interface of BioJava. We can use a
\lstinline+SequenceIterator+ in an adaptor method to obtain a Jstacs \DataSet~including converted annotations:
\addtocounter{off}{7}
\code{0}
The second argument of the method allows for filtering for specific annotations using a BioJava \lstinline+FeatureFilter+.

Vice versa, we can convert a Jstacs \DataSet~to a BioJava \lstinline+SequenceIterator+ by an analogous adaptor method:
\addtocounter{off}{2}
\code{0}

By means of these two methods, we can use all BioJava facilities for loading and storing data from and to diverse file formats and loading data from data bases in our Jstacs applications.

\section{Intermediate course: XMLParser, Parameters, and Results}
\label{sec:xmlparres}

In the early days of Jstacs, we stored models, classifiers, and other Jstacs objects using the standard serialization of Java. However, this mechanism made it impossible to load objects of earlier versions of a class and the files where not human-readable. Hence, we started to create a facility for storing objects to XML representations. In the current version of Jstacs, this is accomplished by an interface \Storable~for objects that can be converted to and from their XML representation, and a class \XMLParser~that can handle such \Storable s, primitives, and arrays thereof. In the first sub-section, we give examples how to use the \XMLParser.

Another problem we wanted to handle has been the documentation of (external) parameters of models, classifiers, or other classes. Although documentation exists in the Javadocs, these are inaccessible from the code. Hence, we created classes for the documentation of parameters and sets of parameters, namely the subclasses of \Parameter~and \ParameterSet. A \Parameter~at least provides the name of and a comment on the parameter that is described. In sub-classes, other values are also available like, for instance, the set or a range of allowed values. Such a description of parameters allows for manifold generic convenience applications. Current examples are the \link{parameters}{ParameterSetTagger}, which facilitates the documentation of command line arguments on basis of a \ParameterSet, or the \link{utils/galaxy}{GalaxyAdaptor}, which allows for an easy integration of Jstacs applications into the Galaxy webserver. We give examples for the use and creation of \Parameter s and \ParameterSet s in the second sub-section.

Finally, the same problem also occurrs for the results of computations. With a generic documentation, these results can be displayed together with some annotation in a way that is appropriate for the current application. In Jstacs, we use \Result s and \ResultSet s for this purpose, and we show how to use these in the third sub-section.

\subsection{XMLParser}
In the following examples, let \lstinline+buffer+ be some \lstinline+StringBuffer+. 
All kinds of primitives or \Storable s are appended to an existing \lstinline+StringBuffer+ surrounded by the specified XML tags by the static method \lstinline+appendObjectWithTags+ of \XMLParser. For example, the following two lines append an integer with the value $5$ using the tag \lstinline+integer+, and a \lstinline+String+ with the tag \lstinline+foo+:
\addtocounter{off}{9}
\code{3}
If we assume that \lstinline+buffer+ was an empty \lstinline+StringBuffer+ before appeding these two elements, the resulting XML text will be
\begin{lstlisting}[language=XML]
<integer>5</integer>
<foo>hallo welt</foo>
\end{lstlisting}
In exactly the same manner, we can append XML representations of arrays of primitives, for example a two-dimensional array of \lstinline+double+ s
\addtocounter{off}{6}
\code{1}
or complete Jstacs models that implement the \Storable~interface
\addtocounter{off}{4}
\code{1}
or even arrays of \Storable s:
\addtocounter{off}{4}
\code{1}
The interface \Storable~only defines two things: first, an implemening class must provide a public method \lstinline+toXML()+ that returns the XML representation of this class as a \lstinline+StringBuffer+, and second, it must provide a constructor that takes a single \lstinline+StringBuffer+ as its argument and re-creates an object out of this representation. The only exception from this rule are singleton, i.e., classes that implement the \Singleton~interface.

Of course, you can use the \lstinline+appendObjectWithTags+ method of the \XMLParser~inside the \lstinline+toXML+ method. By this means, it is possible to break down the conversion of complex models into smaller pieces if the building-blocks of a model are also \Storable s.

In analogy to storing objects, the \XMLParser~also provides facilities for loading primitives and \Storable s from their XML representation. These can also be used in the constructor according to the \Storable~interface. For example, we can load the value of the integer, we stored a few lines ago by calling
\addtocounter{off}{4}
\code{0}
where the second argument of \lstinline+extractObjectForTags+ is the tag surrounding the value and, of course, must be identical to the tag we specified when storing the value. Since \lstinline+extractObjectForTags+ is a generic method, we must explicitly cast the returned value to an \lstinline+Integer+. As an alternative, we can also specify the class of the return type as a third argument like in the following example
\addtocounter{off}{3}
\code{0}
Here, we load the two-dimensional array of \lstinline+double+s that we stored a few lines ago.
In perfect analogy, we can also load a single instance of a class implementing \Storable
\addtocounter{off}{3}
\code{0}
where in this case we again specify the class of the return type in the third argument, or arrays of \Storable
\addtocounter{off}{3}
\code{0}

Of course, we can also specify the concrete sub-class of \Storable~for an array, if all instances are of the same class like in the following example:
\addtocounter{off}{3}
\code{2}

\subsection{Parameters \& ParameterSets}

Parameters in Jstacs are represented by different sub-classes of \Parameter, which define different types of parameters. Parameters that take primitives or strings as values are defined by the class \SimpleParameter, parameters that accept values from some \lstinline+enum+ type are defined by \EnumParameter, parameters where the user can select from a number of predefined values are defined by \SelectionParameter, parameters that represent a file argument are defined by \FileParameter, and parameters that represent a range of values are represented by \RangeParameter.
In the following, we give some examples for the creation of parameter objects. Let us assume, we want to define a parameter for the length of the sequences accepted by some model. The maximum sequence length this model can handle is $100$ and, of course, lengths cannot be negative. We create such a parameter object by the following lines of code:
\addtocounter{off}{9}
\code{0}
The first argument of the constructor defines the data type of the accepted values, which is an \lstinline+int+ in the example. The next two arguments are the name of and the comment for the parameter. The following boolean specifies if this parameter is required (\lstinline+true+) or optional (\lstinline+false+). The \NumberValidator~in the fifth argument allows for specifying the range of allowed values, which is $0$ to $100$ (inclusive) in the example. Finally, we define a default value for this parameter, which is $10$ in the example.
Similarly, we can define a \SimpleParameter~ for some optional parameter that takes strings as values by the following line:
\addtocounter{off}{1}
\code{0}
Again, the second and third arguments are the name and the comment, respectively.

We can define an \EnumParameter, which accept values from some \lstinline+enum+ type as follows
\addtocounter{off}{3}
\code{0}
where the first argument defines the class of the \lstinline+enum+ type, the second is the name of that collection of values, and the third argument again specifies if this parameter is required.

A \SelectionParameter~accepts values from a pre-defined collection of values. For instance, if we want the user to select from two double values $5.0$ and $5E6$, which are named ``small'' and ``large'', we can do so as follows:
\addtocounter{off}{3}
\code{0}

For the special case, where the user shall select the concrete implementation of an abstract class of interface, Jstacs provides a static convenience method \lstinline+getSelectionParameter+ in the class \SubclassFinder. This method requires the specification of the super-class of the \ParameterSet~that can be used to instantiate the implementations, the root package in which sub-classes or implementations shall be found, and, again, a name, a comment, and if this parameter is required.
For example, we can find all classes that can be instantiated by a sub-class of \SequenceScoringParameterSet~the package \lstinline+de+ and its sub-packages by calling
\addtocounter{off}{3}
\code{0}
The method returns a \SelectionParameter~from which a user can select the appropriate implementation.
Classes that can be found in this manner must implement an additional interface called \link{}{InstantiableFromParameterSet}. The main purpose of this interface is that implementing classes must provide a constructor that takes a \InstanceParameterSet~as its only argument in analogy to the constructor of \Storable~working on a \lstinline+StringBuffer+. \InstanceParameterSet s will be explained a few lines below.

As the name suggests, \ParameterSet s represent sets of such parameters. The most simple implementation of a \ParameterSet~is the \SimpleParameterSet, which can be created just from a number of \Parameter s like in the following example:
\addtocounter{off}{3}
\code{0}
Other \ParameterSet s are the \link{parameters}{ExpandableParameterSet} and \link{parameters}{ArrayParameterSet}, which can handle series of identical parameter types.

One special case of \ParameterSet s is the \InstanceParameterSet, which has several sub-classes that can be used to instantiate new Jstacs objects like statistical models, scoring functions, or classifiers. If a new model, say an implementation of the \TrainSM~interface, shall be found via the \SubclassFinder, or its parameters shall be set in a command line program using the \link{parameters}{ParameterSetTagger} or in Galaxy, we need to create a new sub-class of \InstanceParameterSet~that represents all (external) parameters of this model. In this sub-class we must basically implement two methods: \lstinline+getInstanceName+ and \lstinline+getInstanceComment+ return the name of and a comment on the model class (i.e., in the example, the model we just implemented) that may be of help for a potential user. The constructor does the main work. By a call to the super-constructor, it initializes the list of parameters in this set and then adds the parameters of the model.
\addtocounter{off}{20}
%\code{18}
For implementations of the \TrainSM~interface we may also extend \link{parameters}{SequenceScoringParameterSet}, which already handles the \AlphabetContainer~and length of this model.

Not always do we have flat hierarchies of parameters. For instance, the choice of subsequent parameters may depend on the selection from some \SelectionParameter. For this purpose, Jstacs provides a sub-class of \Parameter~that only serves as a container for a \ParameterSet~and is called \link{parameters}{ParameterSetContainer}. Like other parameters, this container takes a name and a comment in its constructor, whereas the third argument is a \ParameterSet:
\addtocounter{off}{3}
\code{0}
Since such a \link{parameters}{ParameterSetContainer} can itself be part of another \ParameterSet, we can build hierarchies or trees of \Parameter s and \ParameterSet s. \link{parameters}{ParameterSetContainer}s are also used internally to create \SelectionParameter s from an array of \ParameterSet s, e.g., for \lstinline+getSelectionParameter+ in the \SubclassFinder.

\subsection{Results \& ResultSets}

We distingiush two types of \Result s, namely \NumericalResult s and \CategoricalResult s. The first are results containing numerical values, which can be aggregated, for instance averaged, while the latter are results of categorial values like strings or booleans. 
For example, we can create a \NumericalResult~containing a single \lstinline+double+ value by the following line
\addtocounter{off}{6}
\code{0}
where, in analogy to \Parameter s, the first and the second argument are the name of and a comment on the result, respectively.

Similarly, we create a \CategoricalResult~by the following line
\addtocounter{off}{3}
\code{0}
for a result that is a single \lstinline+boolean+ value.

As for \ParameterSet s, we can create sets of results using the class \ResultSet
\addtocounter{off}{3}
\code{0}
where we may also combine \NumericalResult s and \CategoricalResult s into a single set. Besides simple \ResultSet s, Jstacs comprises
\NumericalResultSet s for combining only \NumericalResult s, which can be created in complete analogy to \ResultSet s.

Jstacs also provides a special class for averaging \NumericalResult. 
This class is called \MeanResultSet, and computes the average and standard error of the corresponding values of a number of \NumericalResultSet s. The corresponding \NumericalResult s in the \NumericalResultSet~are identified by their name as speficied upon creation.

We first create an empty \MeanResultSet~by calling its default constructor
\addtocounter{off}{3}
\code{0}
and susequently add a number of \NumericalResultSet s to this \MeanResultSet.
\addtocounter{off}{2}
\code{3}
In the example, these are just 10 uniformly distributed random numbers.

Finally, we call the method \lstinline+getStatistics+ of \MeanResultSet~to obtain the mean and standard error of the previously added values.
\addtocounter{off}{4}
\code{0}
the result of this method is again returned as a \NumericalResultSet. In the example, it is just printed to standard out.


\section{First main course: Models}
\newcounter{tempcounter}
\setcounter{tempcounter}{\arabic{off}}

Statistical models that can be learned on a single input data set are represented by the interface \TrainSM~of Jstacs. In most cases, such models are learned by generative learning principles like maximum likelihood or maximum a-posteriori. For models that are learned from multiple data sets, commonly by discriminative learning principles, Jstacs provides another interface \DiffSM, which will be presented in the next section.

In the following, we briefly describe all methods that are defined in the \TrainSM~interface. For convenience, an abstract implementation \AbstractTrainSM~of \TrainSM~exists, which provides standard implementations for many of these methods.

\renewcommand{\codefile}{../../de/jstacs/sequenceScores/SequenceScore.java}
\setcounter{off}{45}


\TrainSM~extends the standard interface \lstinline+Cloneable+ and, hence, implementations must provide a \lstinline+clone()+ method, which returns a deep copy of all fields of an instance:
\code{0}
Since the implementation of the clone method is very model-specific, it must be implemented anew for each implementation of the \TrainSM~interface.

The parameters of statistical models are typically learned from some training data set. For this purpose, \TrainSM~specifies a method \lstinline+train+
\addtocounter{off}{18}
\code{0}
that learns the parameters from the training data set \lstinline+data+. By specification, successive calls to \lstinline+train+ must result in a model trained on the data set provided in the last call, as opposed to incremental learning on all data sets.

Besides this simple \lstinline+train+ method, \TrainSM~also declares another one
\addtocounter{off}{27}
\code{0}
that allows for the specification of weights for each input sequence. Since the previous method is a special case of this one where all weights are equal to $1$, only the weighted variant must be implemented, if you decide to extend \AbstractTrainSM. This method should be implemented such that the specification of \lstinline+null+ weights leads to the standard variant with all weights equal to 1. The actual training method may be totally problem and implementation specific. However, in most cases you might want to use one of the generative learning principles ML or MAP.

After a model has been trained it can be used to compute the likelihood of a sequence given the model and its (trained) parameters. The \TrainSM~interface specifies a number of methods for this purpose.

The first method just requires the specification of the \Sequence~object for which the likelihood is to be computed:
\addtocounter{off}{24}
\code{1}
If the \TrainSM~has not been trained prior to calling this method, it is allowed to throw a \lstinline+NotTrainedException+. The meaning of this method is slightly different for inhomogeneous, that is position-dependent, and homogeneous models. In case of an inhomogeneous model, for instance a position weight matrix, the specified \Sequence~must be of the same length as the model, i.e. the number of columns in the weight matrix. Otherwise an Exception should be thrown, since users may be tempted to misinterpret the return value as a probability of the complete, possibly longer or shorter, provided sequence.
In case of homogeneous models, for instance homogeneous Markov models, this method must return the likelihood of the complete sequence. Since this is not always the desired result, to other methods are specified, which allow for computing the likelihood of sub-sequences. This method should also check if the provided \Sequence~is defined over the same \AlphabetContainer~as the model.

The first of these methods is
\addtocounter{off}{37}
\code{1}
which computes the likelihood of the sub-sequence starting at position \lstinline+startpos+. The resulting value of the likelihood must be the same as if the user had called \lstinline+getProbFor(sequence.getSubSequence(startpos))+.

The second method reads
\addtocounter{off}{40}
\code{1}
and computes the likelihood of the sub-sequence starting at position \lstinline+startpos+ up to position \lstinline+endpos+ (inclusive). The resulting value of the likelihood must be the same as if the user had called \lstinline+getProbFor(sequence.getSubSequence(startpos,endpos-startpos+1))+.
Only the last method must be implemented if we decide for extending \AbstractTrainSM, since the previous two can again be perceived as special cases.

In some cases, for instance for very long sequences, the computation of the likelihood may lead to numerical problems. Hence, the \TrainSM~interface in complete analogy defines methods for computing the log-likelihood. These methods are
\addtocounter{off}{32}
\code{1}
\addtocounter{off}{28}
\code{1}
\addtocounter{off}{28}
\code{0}
Although the implementation of the log-variants is not required if you extend \AbstractTrainSM, we strongly recommend to also implement \lstinline+getLogProbFor(Sequence,int,int)+ because otherwise it defaults to \lstinline+Math.log(getProbFor(Sequence,int,int))+ and, hence, inherits numerical problems that may occur for this method.

For convenience, \TrainSM~also provides a method for computing the log-likelihoods of all \Sequence s in a \DataSet
\addtocounter{off}{25}
\code{0}
which is already implemented in \AbstractTrainSM by successive calls to \lstinline+getLogProbFor(Sequence)+. This method also exists in a variant
\addtocounter{off}{25}
\code{0}
where the user may specify an existing array for storing the computed log-likelihoods. This may be reasonable to save memory, for instance if we compute the log-likelihoods of a large number of sequences using different models.

If we want to use Bayesian principles for learning the parameters of a model, we need to specify a prior distribution on the parameter values. In some cases, for instance for using MAP estimation in an expectation maximization (EM) algorithm, it is not only necessary to estimate the parameters taking the prior into account, but also to know the value of the prior (or a term proportional to it). For this reason, the \TrainSM~interface defines the methods
\addtocounter{off}{11}
\code{0}
and
\addtocounter{off}{13}
\code{0}
which return this prior term and its logarithm, respectively. In the default implementation of \AbstractTrainSM, the first method defaults to \lstinline+Math.exp(getLogPriorTerm())+.

If the concept of a prior is not applicable for a certain model or other reasons prevent you from implementing these methods, \lstinline+getLogPriorTerm()+ should return \lstinline+Double.NEGATIVE_INFINITY+.

Generative \TrainSM s can also be used to create new, artificial data according to the model assumptions. For this purpose, the \TrainSM~interface specifies a method
\addtocounter{off}{50}
\code{1}
wich returns a \DataSet~of \lstinline+numberOfSequences+ \Sequence s drawn from the model using its current parameter values. The second parameter \lstinline+seqLength+ allows for the specification of the lenghts of the drawn \Sequence s. For inhomogeneous model, which inherently define the length of possible sequence, this parameter should be \lstinline+null+ or an array of length 0. For homogeneous models, the lengths may either be specified for all drawn sequences by a single \lstinline+int+ value or by an array of length \lstinline+numberOfSequences+ specifying the length of each drawn sequence independently.

The implementation of this method is not always possible. In its default implementation in \AbstractTrainSM, this method just throws an Exception and must be explicitly overridden to be functional.

\TrainSM~also defines some methods that are basically getters for typical properties of a \TrainSM~implementation. 
These are
\addtocounter{off}{10}
\code{0}
which returns the current \AlphabetContainer~of the model,
\addtocounter{off}{7}
\code{0}
which returns a (helpful) name of the current \TrainSM~instance,
\addtocounter{off}{10}
\code{0}
which returns the length of the \TrainSM~(0 for homogeneous models), and
\addtocounter{off}{10}
\code{0}
which returns the maximum number of preceeding positions that are considered for (conditional) probabilities.
For instance, for a position weight matrix, this method should return 0, whereas for a homogeneous Markov model of order 2, it should return 2.

The method
\addtocounter{off}{9}
\code{0}
must return \lstinline+true+ if the model has already been trained, i.e., the train method has been called at least once, and \lstinline+false+ otherwise.

The methods
\addtocounter{off}{17}
\code{0}
and
\addtocounter{off}{12}
\code{0}
can be used to return some  properties of a \TrainSM~like the number of parameters, the depth of some tree structure, or whatever seems useful. In the latter case, these characteristics are limited to numerical values. If a model is used, e.g., in a cross validation (\KFoldCrossValidation), these numerical properties are averaged over all cross validation iterations and displayed together with the performance measures.

The method
\addtocounter{off}{8}
\code{0}
should return some \lstinline+String+ representation of the current model. Typically, this representation should include the current parameter values in some suitable format.

Finally, the method
\addtocounter{off}{20}
\code{0}
can be used to replace the current \AlphabetContainer~by some (compatible) other \AlphabetContainer.
Compatible means that the new \AlphabetContainer~must define an identical alphabet, although it may be a different instance. This method may be helpful if in successive evaluations the consistency check between alphabets can be reduced to the comparison of references. The default implement in \AbstractTrainSM~should do the right thing in most cases.

\renewcommand{\codefile}{../codeExamples/NewCodeExampleTest.java}
\setcounter{off}{\arabic{tempcounter}}

Besides the possibility to implement new statistical models in Jstacs, many of them are already implemented and can readily be used.
As a central facility for creating model instances of many standard models, Jstacs provides a \TrainSMFactory.

Using the \TrainSMFactory, we can create a new position weight matrix (PWM) model by calling
\addtocounter{off}{10}
\code{0}
where we need to specify the (discrete) alphabet, the length of the matrix ($10$), i.e. the number of positions modeled, and an equivalent sample size (ESS) for MAP estimation ($4.0$). For the concept of an equivalent sample size and the BDeu prior used for most models in Jstacs, we refer the reader to (Heckerman). If the ESS is set to $0.0$, the parameters are estimated by the ML instead of the MAP principle.

The factory method for an inhomogeneous Markov model of arbitrary order -- the PWM model is just an inhomogeneous Markov model of order 0 -- is
\addtocounter{off}{1}
\code{0}
where the parameters are in complete analogy to the PWM model, expect the last one specifying the order of the inhomogeneous Markov model, which is 2 in the example.

We can also create permuted Markov models of order $1$ and $2$, where the positions of the sequences may be permuted before building an inhomogeneous Markov model. The permutation is chosen such that the mutual information between adjacent positions is maximized. We create a permuted Markov model of length 7 and order 1 by calling
\addtocounter{off}{1}
\code{0}

Homogeneous Markov models are created by
\addtocounter{off}{1}
\code{0}
where the first parameter again specifies the alphabet, the second parameter 

\addtocounter{off}{1}
\code{0}

\addtocounter{off}{3}
\code{0}

\addtocounter{off}{3}
\code{0}

\addtocounter{off}{3}
\code{0}

\addtocounter{off}{3}
\code{2}

\addtocounter{off}{5}
\code{3}

\addtocounter{off}{6}
\code{0}

\addtocounter{off}{3}
\code{0}

\addtocounter{off}{3}
\code{0}

\addtocounter{off}{3}
\code{0}

\addtocounter{off}{3}
\code{0}


\section{Second main course: ScoringFunctions}

\section{Third main course: Classifiers}

\section{Intermediate course: Optimization}

\section{Dessert: Alignments}

\section{Like some sweets: Utils and goodies}

\end{document}
